# -*- coding: utf-8 -*-
"""
Input plug-in for a voronoi calculation.
"""
from aiida import orm
from aiida.engine import CalcJob
from aiida.common.exceptions import InputValidationError
from aiida.common.datastructures import (CalcInfo, CodeInfo)
from aiida_kkr.tools.common_workfunctions import (
    generate_inputcard_from_structure,
    check_2Dinput_consistency,
    vca_check,
)
from aiida_kkr.data.kkr_potential import KKRPotentialData

__copyright__ = (u'Copyright (c), 2017, Forschungszentrum Jülich GmbH, ' 'IAS-1/PGI-1, Germany. All rights reserved.')
__license__ = 'MIT license, see LICENSE.txt file'
__version__ = '0.5.3'
__contributors__ = ('Jens Broeder', 'Philipp Rüßmann')


class VoronoiCalculation(CalcJob):
    """
    AiiDA calculation plugin for a voronoi calculation (creation of starting potential and shapefun).
    """

    ####################
    # File names etc.
    ####################
    # calculation plugin version
    _CALCULATION_PLUGIN_VERSION = __version__
    # Default input and output files
    _DEFAULT_INPUT_FILE = 'inputcard'  # will be shown with inputcat
    _DEFAULT_OUTPUT_FILE = 'out_voronoi'  # shell output will be shown with outputcat
    # List of mandatory input files
    _INPUT_FILE_NAME = 'inputcard'
    # List of output files that should always be present
    _OUTPUT_FILE_NAME = 'out_voronoi'
    # template.product entry point defined in setup.json
    _default_parser = 'kkr.voroparser'
    # File names
    _ATOMINFO = 'atominfo.txt'
    _RADII = 'radii.dat'
    _SHAPEFUN = 'shapefun'
    _VERTICES = 'vertices.dat'
    _OUT_POTENTIAL_voronoi = 'output.pot'
    _POTENTIAL_IN_OVERWRITE = 'overwrite_potential'

    @classmethod
    def define(cls, spec):
        """
        define internals and inputs / outputs of calculation
        """
        # reuse base class (i.e. CalcJob) functions
        super(VoronoiCalculation, cls).define(spec)
        # now define input files and parser
        spec.input(
            'metadata.options.parser_name',
            valid_type=str,
            default=cls._default_parser,
            non_db=True,
        )
        spec.input(
            'metadata.options.input_filename',
            valid_type=str,
            default=cls._DEFAULT_INPUT_FILE,
            non_db=True,
        )
        spec.input(
            'metadata.options.output_filename',
            valid_type=str,
            default=cls._DEFAULT_OUTPUT_FILE,
            non_db=True,
        )
        # define input nodes (optional ones have required=False)
        spec.input(
            'parameters',
            valid_type=orm.Dict,
            required=True,
            help='Use a node that specifies the input parameters',
        )
        spec.input(
            'structure',
            valid_type=orm.StructureData,
            required=True,
            help='Use a node that specifies the input crystal structure'
        )
        spec.input(
            'potential_overwrite',
            valid_type=orm.SinglefileData,
            required=False,
            help='Use a node that specifies the potential which is used instead of the voronoi output potential'
        )
        # define outputs
        spec.output(
            'output_parameters',
            valid_type=orm.Dict,
            required=True,
            help='results of the calculation',
        )
        spec.output(
            'potential',
            valid_type=KKRPotentialData,
            required=True,
            help='KKR potential generated by the Voronoi code',
        )
        spec.output(
            'shape_function',
            valid_type=orm.SinglefileData,
            required=False,
            help='File with the shape functions for full potential calculation',
        )
        spec.default_output_node = 'output_parameters'
        # define exit codes, also used in parser
        spec.exit_code(
            301,
            'ERROR_NO_RETRIEVED_FOLDER',
            message='the retrieved folder data node could not be accessed.',
            invalidates_cache=True
        )
        spec.exit_code(
            302,
            'ERROR_VORONOI_PARSING_FAILED',
            message='Voronoi parser returned an error',
        )
        spec.exit_code(
            303,
            'ERROR_CRITICAL_MISSING_FILE',
            message='a file that is marked by the parser as critical is missing.',
            invalidates_cache=True
        )

    def prepare_for_submission(self, tempfolder):
        """Create the input files from the input nodes passed to this instance of the `CalcJob`.

        :param tempfolder: an `aiida.common.folders.Folder` to temporarily write files on disk
        :return: `aiida.common.datastructures.CalcInfo` instance
        """

        vca_structure = False
        # for VCA: check if input structure and parameter node define VCA structure
        vca_structure = vca_check(self.inputs.structure, self.inputs.parameters)

        ###################################
        # Check for 2D case
        two_dim_check, msg = check_2Dinput_consistency(self.inputs.structure, self.inputs.parameters)
        if not two_dim_check:
            raise InputValidationError(msg)

        # Prepare inputcard from Structure and input parameter data
        with tempfolder.open(self._INPUT_FILE_NAME, u'w') as input_file:
            try:
                use_alat_input = self.inputs.parameters.get_dict().get('use_input_alat', False)
                use_alat_input = self.inputs.parameters.get_dict().get('USE_INPUT_ALAT', use_alat_input)
                natom, nspin, newsosol, warnings_write_inputcard = generate_inputcard_from_structure(
                    self.inputs.parameters,
                    self.inputs.structure,
                    input_file,
                    isvoronoi=True,
                    vca_structure=vca_structure,
                    use_input_alat=use_alat_input,
                )
            except ValueError as _error:
                raise InputValidationError(f'Input Dict not consistent: {_error}')

        # Decide what files to copy
        local_copy_list = []
        if 'potential_overwrite' in self.inputs:
            # copy the right files #TODO check first if file, exists and throw
            # warning, now this will throw an error
            local_copy_list.append((
                self.inputs.potential_overwrite.uuid, self.inputs.potential_overwrite.filename,
                self._POTENTIAL_IN_OVERWRITE
            ))

        # Prepare CalcInfo to be returned to aiida
        calcinfo = CalcInfo()
        calcinfo.uuid = self.uuid
        calcinfo.local_copy_list = local_copy_list
        calcinfo.remote_copy_list = []
        calcinfo.retrieve_list = [
            self._OUTPUT_FILE_NAME,
            self._ATOMINFO,
            self._RADII,
            self._SHAPEFUN,
            self._VERTICES,
            self._INPUT_FILE_NAME,
        ]

        # pass on overwrite potential if this was given in input
        # (KkrCalculation checks if this file is there and takes this file
        # instead of _OUT_POTENTIAL_voronoi if given)
        if 'potential_overwrite' in self.inputs:
            calcinfo.retrieve_list += [self._POTENTIAL_IN_OVERWRITE]
        else:
            calcinfo.retrieve_list += [self._OUT_POTENTIAL_voronoi]

        codeinfo = CodeInfo()
        codeinfo.cmdline_params = []
        codeinfo.stdout_name = self._OUTPUT_FILE_NAME
        codeinfo.code_uuid = self.inputs.code.uuid
        calcinfo.codes_info = [codeinfo]

        return calcinfo
